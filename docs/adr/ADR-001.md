# ADR-001: Select Next.js as the Frontend Framework

- **Status:** Accepted
- **Date:** 2026-01-28
- **Deciders:** Team (Lead Architect: Ivan Herndon)
- **Context / Drivers:**
  - We need a web-based agent dashboard for the Week 8 prototype that supports rapid iteration and a clean developer workflow.
  - The UI must handle near-real-time updates (transcript, checklist state, sentiment, composite threat score).
  - The team is small (2 members) and the project timeline is short; we need strong defaults, predictable structure, and fast development velocity.
  - We anticipate typical web-app needs even in a prototype: routing, API integration, basic auth/session patterns, and deployment simplicity.

## Decision

We will build the frontend using **Next.js** (React-based framework).

## Rationale

Next.js provides:

- A structured, convention-based project layout that reduces overhead for a small team.
- Strong local developer experience and production-grade build tooling.
- Flexible rendering options (client-side + server-side patterns) that can support performance and incremental adoption of server-side capabilities if needed.
- Straightforward integration with backend APIs and real-time update mechanisms (e.g., SSE/WebSocket client handling).
- A large ecosystem and common community patterns, reducing risk of “framework friction” during a compressed schedule.

## Alternatives Considered

1. **Vite + React (SPA)**
   - Pros: simple, fast dev server, minimal framework opinions
   - Cons: more manual decisions around routing, data fetching patterns, and production structure; higher coordination cost for a small team
2. **Angular**
   - Pros: very structured, batteries included
   - Cons: heavier framework footprint; higher ramp-up cost relative to team familiarity and timeline
3. **Vue / Nuxt**
   - Pros: productive, good DX
   - Cons: less aligned with team’s default stack and existing React ecosystem assumptions

## Consequences

### Positive

- Faster prototyping and iteration due to conventions and tooling.
- Easier to keep UI code organized and maintainable as features expand.
- Lower integration risk for routing, environment config, and deployment.

### Negative / Risks

- Next.js introduces framework-specific conventions that can be overkill for a small prototype.
- If we overuse server-side features prematurely, complexity can rise quickly.

### Mitigations

- Keep the UI scope narrow: dashboard + call session flow + policy upload/admin pages (as required).
- Use simple patterns first (client-side rendering where appropriate) and only adopt server-side features when a clear need emerges.

## Week 4 Consequences Update (Architecture Stress Test)

### New/clarified consequences discovered

- The frontend framework choice does not materially affect the primary scaling bottleneck identified in the Week 4 stress test (the Analysis Orchestrator and external API rate limits). However, it does affect how we present latency and partial results.
- Next.js helps us implement a responsive UI that can render incremental updates (SSE/WebSocket) and maintain perceived responsiveness even when analysis results lag.

### UI-related risks (clarified)

- If we over-invest in server-side features prematurely, we could increase complexity without reducing the real bottlenecks. For the prototype, we will keep the UI focused on streaming presentation and user workflow, not backend substitution.

### Mitigation reaffirmed

- Keep frontend responsibilities narrow: session UX + real-time rendering + basic controls.
- Treat analysis delays as a normal state: show “pending” indicators and partial results rather than blocking.
